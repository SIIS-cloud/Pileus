diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/api/auth.py nova/api/auth.py
--- original/nova-2015.1.1/nova/api/auth.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/api/auth.py	2016-04-10 19:33:17.506932806 -0400
@@ -149,6 +149,9 @@
         # middleware in newer versions.
         user_auth_plugin = req.environ.get('keystone.token_auth')
 
+        # SYQ
+        label = req.headers.get('Label')
+        
         ctx = context.RequestContext(user_id,
                                      project_id,
                                      user_name=user_name,
@@ -158,7 +161,8 @@
                                      remote_address=remote_address,
                                      service_catalog=service_catalog,
                                      request_id=req_id,
-                                     user_auth_plugin=user_auth_plugin)
+                                     user_auth_plugin=user_auth_plugin,
+                                     label=label)
 
         req.environ['nova.context'] = ctx
         return self.application
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/api/openstack/compute/contrib/floating_ips.py nova/api/openstack/compute/contrib/floating_ips.py
--- original/nova-2015.1.1/nova/api/openstack/compute/contrib/floating_ips.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/api/openstack/compute/contrib/floating_ips.py	2016-04-10 19:33:17.590934672 -0400
@@ -46,7 +46,12 @@
     except (TypeError, KeyError, AttributeError):
         result['fixed_ip'] = None
     try:
-        result['instance_id'] = floating_ip['fixed_ip']['instance_uuid']
+        # NOTE(jamespage) neutron based data uses a slight different
+        # underlying data format - use that if present
+        if 'instance' in floating_ip:
+            result['instance_id'] = floating_ip['instance']['uuid']
+        else:
+            result['instance_id'] = floating_ip['fixed_ip']['instance_uuid']
     except (TypeError, KeyError, AttributeError):
         result['instance_id'] = None
     return {'floating_ip': result}
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/api/openstack/compute/servers.py nova/api/openstack/compute/servers.py
--- original/nova-2015.1.1/nova/api/openstack/compute/servers.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/api/openstack/compute/servers.py	2016-04-10 19:33:17.594934761 -0400
@@ -42,6 +42,8 @@
 from nova import policy
 from nova import utils
 
+import traceback
+import inspect
 
 server_opts = [
     cfg.BoolOpt('enable_instance_password',
@@ -144,6 +146,13 @@
         context = req.environ['nova.context']
         remove_invalid_options(context, search_opts,
                 self._get_server_search_options())
+    
+        # LOG.debug('SYQ: get servers')
+        # LOG.debug('SYQ: %s', inspect.stack())
+        # newfile = open("/var/log/nova/test.log", "w")
+        #for entry in inspect.stack():
+        #    print entry[1:]
+        # newfile.close()
 
         # Verify search by 'status' contains a valid status.
         # Convert it to filter by vm_state or task_state for compute_api.
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/api/openstack/wsgi.py nova/api/openstack/wsgi.py
--- original/nova-2015.1.1/nova/api/openstack/wsgi.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/api/openstack/wsgi.py	2016-04-10 19:33:17.598934849 -0400
@@ -35,6 +35,15 @@
 from nova import utils
 from nova import wsgi
 
+# SYQ
+from multiprocessing import Process, Queue, Pipe
+from eventlet import greenthread
+import os
+import sys
+from oslo_messaging import globalvariable as globalv
+
+from nova import rpc
+from nova.objects import base as objects_base
 
 LOG = logging.getLogger(__name__)
 
@@ -755,6 +764,7 @@
         return self._process_stack(request, action, action_args,
                                content_type, body, accept)
 
+
     def _process_stack(self, request, action, action_args,
                        content_type, body, accept):
         """Implement the processing stack."""
@@ -811,57 +821,157 @@
                      'context_project_id': context.project_id}
             return Fault(webob.exc.HTTPBadRequest(explanation=msg))
 
-        # Run pre-processing extensions
-        response, post = self.pre_process_extensions(extensions,
-                                                     request, action_args)
+        # SYQ
+        label = context.label
 
-        if not response:
-            try:
-                with ResourceExceptionHandler():
-                    action_result = self.dispatch(meth, request, action_args)
-            except Fault as ex:
-                response = ex
-
-        if not response:
-            # No exceptions; convert action_result into a
-            # ResponseObject
-            resp_obj = None
-            if type(action_result) is dict or action_result is None:
-                resp_obj = ResponseObject(action_result)
-            elif isinstance(action_result, ResponseObject):
-                resp_obj = action_result
-            else:
-                response = action_result
+        # SYQ
+        def process_request():
+            # Run pre-processing extensions
+            response, post = self.pre_process_extensions(extensions,
+                                                         request, action_args)
 
-            # Run post-processing extensions
-            if resp_obj:
-                # Do a preserialize to set up the response object
-                serializers = getattr(meth, 'wsgi_serializers', {})
-                resp_obj._bind_method_serializers(serializers)
-                if hasattr(meth, 'wsgi_code'):
-                    resp_obj._default_code = meth.wsgi_code
-                resp_obj.preserialize(accept, self.default_serializers)
-
-                # Process post-processing extensions
-                response = self.post_process_extensions(post, resp_obj,
-                                                        request, action_args)
-
-            if resp_obj and not response:
-                response = resp_obj.serialize(request, accept,
-                                              self.default_serializers)
-
-        if hasattr(response, 'headers'):
-
-            for hdr, val in response.headers.items():
-                # Headers must be utf-8 strings
-                response.headers[hdr] = utils.utf8(str(val))
-
-            if not request.api_version_request.is_null():
-                response.headers[API_VERSION_REQUEST_HEADER] = \
-                    request.api_version_request.get_string()
-                response.headers['Vary'] = API_VERSION_REQUEST_HEADER
-
-        return response
+            if not response:
+                try:
+                    with ResourceExceptionHandler():
+                        action_result = self.dispatch(meth, request, action_args)
+                except Fault as ex:
+                    response = ex
+    
+            if not response:
+                # No exceptions; convert action_result into a
+                # ResponseObject
+                resp_obj = None
+                if type(action_result) is dict or action_result is None:
+                    resp_obj = ResponseObject(action_result)
+                elif isinstance(action_result, ResponseObject):
+                    resp_obj = action_result
+                else:
+                    response = action_result
+    
+                # Run post-processing extensions
+                if resp_obj:
+                    # Do a preserialize to set up the response object
+                    serializers = getattr(meth, 'wsgi_serializers', {})
+                    resp_obj._bind_method_serializers(serializers)
+                    if hasattr(meth, 'wsgi_code'):
+                        resp_obj._default_code = meth.wsgi_code
+                    resp_obj.preserialize(accept, self.default_serializers)
+    
+                    # Process post-processing extensions
+                    response = self.post_process_extensions(post, resp_obj,
+                                                            request, action_args)
+
+                if resp_obj and not response:
+                    response = resp_obj.serialize(request, accept,
+                                                  self.default_serializers)
+            if hasattr(response, 'headers'):
+    
+                for hdr, val in response.headers.items():
+                    # Headers must be utf-8 strings
+                    response.headers[hdr] = utils.utf8(str(val))
+    
+                if not request.api_version_request.is_null():
+                    response.headers[API_VERSION_REQUEST_HEADER] = \
+                        request.api_version_request.get_string()
+                    response.headers['Vary'] = API_VERSION_REQUEST_HEADER
+
+            return response
+
+        # SYQ
+        if not globalv.serviceObj.pileus_debug: 
+            result = process_request()
+            return result
+        
+        def spawn_with_label(child_pipe, parent_pipe):
+            # Let's confine it with label 1;|1;
+            pid = os.getpid()
+            print '******************SYQ: pid is %s************************'%pid
+            
+            labels = label.split('|')
+            secrecy_label = labels[0]
+            integrity_label = labels[1]
+
+            path = "/proc/%s"%pid
+            slabel = open('%s/set_secrecy'%path,'w')
+            ilabel = open('%s/set_integrity'%path,'w')
+            confined = open('%s/confined'%path, 'w')
+            slabel.write(secrecy_label)
+            slabel.close()
+            ilabel.write(integrity_label)
+            ilabel.close()
+            confined.write("1")
+            confined.close()
+        
+            with open('%s/labels'%path,'r') as f:
+                lines = f.readlines()
+            LOG.debug("****************SYQ: my label is*********************")
+            LOG.debug(lines)
+            LOG.debug("*****************************************************")
+
+            if getattr(globalv, 'isDaemon'):
+                globalv.isDaemon = False
+            if getattr(globalv, 'serviceObj', None) is None:
+                print '***************SYQ: cannot find serviceObj in globalv, service has not inited'
+                sys.exit()
+            globalv.serviceObj.set_pipe(child_pipe, parent_pipe)
+                
+            result = process_request()
+            if isinstance(result, Fault):
+                ret_msg = {'type': 'END', 'response': result.wrapped_exc, 'exception' : True}
+            else:
+                ret_msg = {'type': 'END', 'response': result, 'exception' : False}
+            child_pipe.send(ret_msg)
+            child_pipe.close()
+
+        parent_r_pipe, child_w_pipe = Pipe()
+        parent_w_pipe, child_r_pipe = Pipe()
+        p = Process(target=spawn_with_label, args=(child_w_pipe, child_r_pipe, ))
+        p.start()
+        while True:
+            if parent_r_pipe.poll():
+                ret_msg = parent_r_pipe.recv()
+                if ret_msg.get('type', None) == 'END':
+                    response = ret_msg['response']
+                    if ret_msg['exception']:
+                        return Fault(response)
+                    else:
+                        return response
+                elif ret_msg.get('type', None) == 'MSG':
+                    # Proxy message for cloud service instances
+                    target = ret_msg['target']
+                    #serializer_name = ret_msg['serializer']
+                    #serializer = getattr(globals()['objects_base'], serializer_name)()
+                    serializer = ret_msg['serializer']
+                    #version = ret_msg['version']
+                    method = ret_msg['method']
+                    kwargs = ret_msg['args']
+                    context = ret_msg['context']
+                    func = ret_msg['func']
+                    if serializer is None:
+                        client = rpc.get_client(target)
+                    else:
+                        client = rpc.get_client(target, serializer=serializer)
+                    prep_args = ret_msg.get('prep_args')
+                    if prep_args is None:
+                        cctxt = client.prepare()
+                    else:
+                        cctxt = client.prepare(**prep_args)
+                    try:
+                        if func == 'cast':
+                            cctxt.cast(context, method, **kwargs)
+                            parent_w_pipe.send({'exception': False})
+                        elif func == 'call':
+                            res = cctxt.call(context, method, **kwargs)
+                            parent_w_pipe.send({'exception': False, 'response': res})
+                        else:
+                            print '*************SYQ: unsupported method'
+                    except Exception as ex:
+                        print '*********************SYQ: exception %s'%type(ex)
+                        parent_w_pipe.send({'exception': True, 'ex': ex})  
+                else:
+                    print 'http request'
+            greenthread.sleep(0)
+        p.join()
 
     def get_method(self, request, action, content_type, body):
         meth, extensions = self._get_method(request,
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/CA/.gitignore nova/CA/.gitignore
--- original/nova-2015.1.1/nova/CA/.gitignore	2015-07-28 15:53:35.000000000 -0400
+++ nova/CA/.gitignore	1969-12-31 19:00:00.000000000 -0500
@@ -1,11 +0,0 @@
-index.txt
-index.txt.old
-index.txt.attr
-index.txt.attr.old
-cacert.pem
-serial
-serial.old
-openssl.cnf
-private/*
-newcerts/*
-
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/CA/projects/.gitignore nova/CA/projects/.gitignore
--- original/nova-2015.1.1/nova/CA/projects/.gitignore	2015-07-28 15:53:35.000000000 -0400
+++ nova/CA/projects/.gitignore	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-*
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/CA/reqs/.gitignore nova/CA/reqs/.gitignore
--- original/nova-2015.1.1/nova/CA/reqs/.gitignore	2015-07-28 15:53:35.000000000 -0400
+++ nova/CA/reqs/.gitignore	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-*
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/cmd/api.py nova/cmd/api.py
--- original/nova-2015.1.1/nova/cmd/api.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/cmd/api.py	2016-04-10 19:33:17.246927030 -0400
@@ -53,5 +53,7 @@
                                          max_url_len=16384)
         else:
             server = service.WSGIService(api, use_ssl=should_use_ssl)
+        # SYQ
+        #server.pileus_debug = True 
         launcher.launch_service(server, workers=server.workers or 1)
     launcher.wait()
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/cmd/compute.py nova/cmd/compute.py
--- original/nova-2015.1.1/nova/cmd/compute.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/cmd/compute.py	2016-04-10 19:33:17.258927297 -0400
@@ -70,5 +70,9 @@
     server = service.Service.create(binary='nova-compute',
                                     topic=CONF.compute_topic,
                                     db_allowed=CONF.conductor.use_local)
+
+    # SYQ
+    #server.pileus_debug = True 
+
     service.serve(server)
     service.wait()
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/cmd/conductor.py nova/cmd/conductor.py
--- original/nova-2015.1.1/nova/cmd/conductor.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/cmd/conductor.py	2016-04-10 19:33:17.250927119 -0400
@@ -42,6 +42,8 @@
     server = service.Service.create(binary='nova-conductor',
                                     topic=CONF.conductor.topic,
                                     manager=CONF.conductor.manager)
+    # SYQ
+    server.is_conductor = True
     workers = CONF.conductor.workers or processutils.get_worker_count()
     service.serve(server, workers=workers)
     service.wait()
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/cmd/network.py nova/cmd/network.py
--- original/nova-2015.1.1/nova/cmd/network.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/cmd/network.py	2016-04-10 19:33:17.230926675 -0400
@@ -70,5 +70,8 @@
     server = service.Service.create(binary='nova-network',
                                     topic=CONF.network_topic,
                                     db_allowed=CONF.conductor.use_local)
+    # SYQ
+    #server.pileus_debug = True 
+
     service.serve(server)
     service.wait()
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/compute/manager.py nova/compute/manager.py
--- original/nova-2015.1.1/nova/compute/manager.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/compute/manager.py	2016-04-10 19:33:17.406930584 -0400
@@ -94,6 +94,8 @@
 from nova import volume
 from nova.volume import encryptors
 
+# SYQ
+import os
 
 compute_opts = [
     cfg.StrOpt('console_host',
@@ -703,6 +705,8 @@
                             self.driver.need_legacy_block_device_info
 
     def _get_resource_tracker(self, nodename):
+        # SYQ
+        print '*************SYQ: in get_resource_tracker'
         rt = self._resource_tracker_dict.get(nodename)
         if not rt:
             if not self.driver.node_is_available(nodename):
@@ -719,6 +723,10 @@
     def _update_resource_tracker(self, context, instance):
         """Let the resource tracker know that an instance has changed state."""
 
+        # SYQ
+        print '************SYQ: in update_resource_tracker'
+        print '*************instance[host] == self.host : %s'%(instance['host'] == self.host)
+        print '************SYQ: node is avaiable: %s'%self.driver.node_is_available(instance['node'])
         if (instance['host'] == self.host and
                 self.driver.node_is_available(instance['node'])):
             rt = self._get_resource_tracker(instance.get('node'))
@@ -1864,6 +1872,7 @@
         self._update_resource_tracker(context, instance)
 
         is_vpn = pipelib.is_vpn_image(instance.image_ref)
+
         return network_model.NetworkInfoAsyncWrapper(
                 self._allocate_network_async, context, instance,
                 requested_networks, macs, security_groups, is_vpn,
@@ -2152,6 +2161,7 @@
                      security_groups=None, block_device_mapping=None,
                      node=None, limits=None):
 
+        print '****************SYQ: build_and_run_instance pid %s started'%os.getpid()
         # NOTE(danms): Remove this in v4.0 of the RPC API
         if (requested_networks and
                 not isinstance(requested_networks,
@@ -2186,11 +2196,14 @@
         # NOTE(danms): We spawn here to return the RPC worker thread back to
         # the pool. Since what follows could take a really long time, we don't
         # want to tie up RPC workers.
-        utils.spawn_n(_locked_do_build_and_run_instance,
+        # SYQ
+        #utils.spawn_n(_locked_do_build_and_run_instance,
+        utils.block_spawn(_locked_do_build_and_run_instance,
                       context, instance, image, request_spec,
                       filter_properties, admin_password, injected_files,
                       requested_networks, security_groups,
                       block_device_mapping, node, limits)
+        print '****************SYQ: build_and_run_instance pid %s done'%os.getpid()
 
     @hooks.add_hook('build_instance')
     @wrap_exception()
@@ -2201,7 +2214,6 @@
             request_spec, filter_properties, admin_password, injected_files,
             requested_networks, security_groups, block_device_mapping,
             node=None, limits=None):
-
         try:
             LOG.info(_LI('Starting instance...'), context=context,
                   instance=instance)
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/conductor/manager.py nova/conductor/manager.py
--- original/nova-2015.1.1/nova/conductor/manager.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/conductor/manager.py	2016-04-10 19:33:17.474932095 -0400
@@ -17,6 +17,9 @@
 import copy
 import itertools
 
+# SYQ
+import inspect
+
 from oslo_log import log as logging
 import oslo_messaging as messaging
 from oslo_serialization import jsonutils
@@ -691,7 +694,7 @@
             # instance specific information
             bdms = objects.BlockDeviceMappingList.get_by_instance_uuid(
                     context, instance.uuid)
-
+            
             self.compute_rpcapi.build_and_run_instance(context,
                     instance=instance, host=host['host'], image=image,
                     request_spec=request_spec,
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/conductor/rpcapi.py nova/conductor/rpcapi.py
--- original/nova-2015.1.1/nova/conductor/rpcapi.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/conductor/rpcapi.py	2016-04-10 19:33:17.474932095 -0400
@@ -15,6 +15,10 @@
 
 """Client side of the conductor RPC API."""
 
+# SYQ
+import inspect
+from oslo_messaging import globalvariable as globalv
+
 from oslo_config import cfg
 import oslo_messaging as messaging
 from oslo_serialization import jsonutils
@@ -183,15 +187,27 @@
         self.client = rpc.get_client(target,
                                      version_cap=version_cap,
                                      serializer=serializer)
+        # SYQ
+        self.target = target
+        self.serializer = serializer
+        self.serializer_name = 'NovaObjectSerializer' 
 
     def instance_update(self, context, instance_uuid, updates,
                         service=None):
         updates_p = jsonutils.to_primitive(updates)
         cctxt = self.client.prepare()
-        return cctxt.call(context, 'instance_update',
-                          instance_uuid=instance_uuid,
-                          updates=updates_p,
-                          service=service)
+        # SYQ
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.call(context, 'instance_update',
+                              instance_uuid=instance_uuid,
+                              updates=updates_p,
+                              service=service)
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, 
+                                    None, context, 'instance_update', 
+                                    instance_uuid=instance_uuid, 
+                                    updates=updates_p, 
+                                    service=service)
 
     def migration_get_in_progress_by_host_and_node(self, context,
                                                    host, node):
@@ -208,7 +224,12 @@
 
     def provider_fw_rule_get_all(self, context):
         cctxt = self.client.prepare()
-        return cctxt.call(context, 'provider_fw_rule_get_all')
+        # SYQ
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.call(context, 'provider_fw_rule_get_all')
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, None, 
+                                    context, 'provider_fw_rule_get_all')
 
     def block_device_mapping_update_or_create(self, context, values,
                                               create=None):
@@ -270,6 +291,7 @@
         cctxt = self.client.prepare()
         return cctxt.call(context, 'compute_node_delete', node=node_p)
 
+    # SYQ
     def service_update(self, context, service, values):
         service_p = jsonutils.to_primitive(service)
 
@@ -316,10 +338,18 @@
         return cctxt.call(context, 'security_groups_trigger_handler',
                           event=event, args=args_p)
 
+    # SYQ
     def security_groups_trigger_members_refresh(self, context, group_ids):
         cctxt = self.client.prepare()
-        return cctxt.call(context, 'security_groups_trigger_members_refresh',
-                          group_ids=group_ids)
+        #return cctxt.call(context, 'security_groups_trigger_members_refresh',
+        #                  group_ids=group_ids)
+        if getattr(globalv, 'isDaemon', True) == True:
+            return cctxt.call(context, 'security_groups_trigger_members_refresh',
+                              group_ids=group_ids)
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, None,
+                                    context, 'security_groups_trigger_members_refresh', 
+                                    group_ids=group_ids)
 
     def get_ec2_ids(self, context, instance):
         instance_p = jsonutils.to_primitive(instance)
@@ -327,17 +357,34 @@
         return cctxt.call(context, 'get_ec2_ids',
                           instance=instance_p)
 
+    # SYQ
     def object_class_action(self, context, objname, objmethod, objver,
                             args, kwargs):
         cctxt = self.client.prepare()
-        return cctxt.call(context, 'object_class_action',
-                          objname=objname, objmethod=objmethod,
-                          objver=objver, args=args, kwargs=kwargs)
+        #return cctxt.call(context, 'object_class_action',
+        #                  objname=objname, objmethod=objmethod,
+        #                  objver=objver, args=args, kwargs=kwargs)
+        if getattr(globalv, 'isDaemon', True) == True:
+            return cctxt.call(context, 'object_class_action',
+                              objname=objname, objmethod=objmethod,
+                              objver=objver, args=args, kwargs=kwargs)
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, None, context, 
+                                    'object_class_action', objname=objname, objmethod=objmethod,
+                                    objver=objver, args=args, kwargs=kwargs)
 
+    # SYQ
     def object_action(self, context, objinst, objmethod, args, kwargs):
         cctxt = self.client.prepare()
-        return cctxt.call(context, 'object_action', objinst=objinst,
-                          objmethod=objmethod, args=args, kwargs=kwargs)
+        #return cctxt.call(context, 'object_action', objinst=objinst,
+        #                    objmethod=objmethod, args=args, kwargs=kwargs)
+        if getattr(globalv, 'isDaemon', True) == True:
+            return cctxt.call(context, 'object_action', objinst=objinst,
+                                objmethod=objmethod, args=args, kwargs=kwargs)
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, None, 
+                                    context, 'object_action', objinst=objinst, 
+                                    objmethod=objmethod, args=args, kwargs=kwargs)
 
     def object_backport(self, context, objinst, target_version):
         cctxt = self.client.prepare()
@@ -372,6 +419,10 @@
                                   version='1.0')
         serializer = objects_base.NovaObjectSerializer()
         self.client = rpc.get_client(target, serializer=serializer)
+        # SYQ
+        self.target = target
+        self.serializer = serializer
+        self.serializer_name = 'NovaObjectSerializer'
 
     def migrate_server(self, context, instance, scheduler_hint, live, rebuild,
                   flavor, block_migration, disk_over_commit,
@@ -422,9 +473,16 @@
             bdm_p = objects_base.obj_to_primitive(block_device_mapping)
             kw.update({'block_device_mapping': bdm_p,
                        'legacy_bdm': legacy_bdm})
-
+        # SYQ
+        # oslo_messaging.rpc.client._CallContext
         cctxt = self.client.prepare(version=version)
-        cctxt.cast(context, 'build_instances', **kw)
+        if getattr(globalv, 'isDaemon', True):
+            cctxt.cast(context, 'build_instances', **kw)
+        else:
+            args = {'version': version}
+            cctxt.cast_daemon(self.target, self.serializer, args, 
+                                context, 'build_instances', **kw)
+            #cctxt.cast_daemon_v2(self.client, version, context, 'build_instances', **kw)
 
     def unshelve_instance(self, context, instance):
         cctxt = self.client.prepare(version='1.3')
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/consoleauth/rpcapi.py nova/consoleauth/rpcapi.py
--- original/nova-2015.1.1/nova/consoleauth/rpcapi.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/consoleauth/rpcapi.py	2016-04-10 19:33:18.402952711 -0400
@@ -21,6 +21,9 @@
 
 from nova import rpc
 
+# SYQ
+from oslo_messaging import globalvariable as globalv
+
 CONF = cfg.CONF
 
 rpcapi_cap_opt = cfg.StrOpt('consoleauth',
@@ -69,6 +72,8 @@
         version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.consoleauth,
                                                CONF.upgrade_levels.consoleauth)
         self.client = rpc.get_client(target, version_cap=version_cap)
+        # SYQ
+        self.target = target
 
     def authorize_console(self, ctxt, token, console_type, host, port,
                           internal_access_path, instance_uuid,
@@ -94,6 +99,13 @@
 
     def delete_tokens_for_instance(self, ctxt, instance_uuid):
         cctxt = self.client.prepare()
-        return cctxt.cast(ctxt,
-                          'delete_tokens_for_instance',
-                          instance_uuid=instance_uuid)
+        # SYQ
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.cast(ctxt,
+                              'delete_tokens_for_instance',
+                              instance_uuid=instance_uuid)
+        else:
+            return cctxt.cast_daemon(self.target, None, 
+                                    None, ctxt, 
+                                    'delete_tokens_for_instance', 
+                                    instance_uuid=instance_uuid)
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/context.py nova/context.py
--- original/nova-2015.1.1/nova/context.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/context.py	2016-04-10 19:33:17.266927474 -0400
@@ -73,7 +73,7 @@
                  request_id=None, auth_token=None, overwrite=True,
                  quota_class=None, user_name=None, project_name=None,
                  service_catalog=None, instance_lock_checked=False,
-                 user_auth_plugin=None, **kwargs):
+                 user_auth_plugin=None, label=None, **kwargs):
         """:param read_deleted: 'no' indicates deleted records are hidden,
                 'yes' indicates deleted records are visible,
                 'only' indicates that *only* deleted records are visible.
@@ -101,7 +101,8 @@
             show_deleted=kwargs.pop('show_deleted', False),
             request_id=request_id,
             resource_uuid=kwargs.pop('resource_uuid', None),
-            overwrite=overwrite)
+            overwrite=overwrite,
+            label=label)
         # oslo_context's RequestContext.to_dict() generates this field, we can
         # safely ignore this as we don't use it.
         kwargs.pop('user_identity', None)
@@ -144,6 +145,11 @@
         if self.is_admin is None:
             self.is_admin = policy.check_is_admin(self)
 
+        if label is not None:
+            self.label = label
+        else:
+            self.label = '|'
+
     def get_auth_plugin(self):
         if self.user_auth_plugin:
             return self.user_auth_plugin
@@ -185,7 +191,8 @@
             'service_catalog': getattr(self, 'service_catalog', None),
             'project_name': getattr(self, 'project_name', None),
             'instance_lock_checked': getattr(self, 'instance_lock_checked',
-                                             False)
+                                             False),
+            'label': getattr(self, 'label', '|')
         })
         return values
 
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/db/sqlalchemy/api.py nova/db/sqlalchemy/api.py
--- original/nova-2015.1.1/nova/db/sqlalchemy/api.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/db/sqlalchemy/api.py	2016-04-10 19:33:18.438953511 -0400
@@ -325,6 +325,11 @@
 
     query = sqlalchemyutils.model_query(model, session, args, **query_kwargs)
 
+    # SYQ
+    with open('/var/log/nova/query-log','a') as f:
+        f.write('\nmodel: %s'%model)
+        f.write('\nquery: %s\n'%query)
+
     # We can't use oslo.db model_query's project_id here, as it doesn't allow
     # us to return both our projects and unowned projects.
     if nova.context.is_user_context(context) and project_only:
@@ -1384,6 +1389,20 @@
                           asc(models.VirtualInterface.id)).\
                  all()
 
+    # SYQ
+    # result is object e.g., FixedIP type
+    # model_query is Query type, defined in sqlalchemy.orm.query
+    """
+    print '****************SYQ******************'
+    a = model_query(context, models.FixedIp, read_deleted="no")
+    print 'query is %s'%type(a)
+    print 'a is %s'%a
+    b = a.filter_by(instance_uuid=instance_uuid).outerjoin(models.VirtualInterface, vif_and).options(contains_eager("virtual_interface")).options(joinedload('network')).options(joinedload('floating_ips')).order_by(asc(models.VirtualInterface.created_at),asc(models.VirtualInterface.id))
+    print 'b is type: %s\n%s'%(type(b),b)
+    print 'result is %s'%result
+    print '*************************************'
+    """
+
     if not result:
         raise exception.FixedIpNotFoundForInstance(instance_uuid=instance_uuid)
 
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/exception.py nova/exception.py
--- original/nova-2015.1.1/nova/exception.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/exception.py	2016-04-10 19:33:17.406930584 -0400
@@ -138,6 +138,12 @@
         # which should be our full NovaException message, (see __init__)
         return self.args[0]
 
+    # SYQ
+    def serialize(self):
+        ex_msg = {}
+        ex_msg['ex_name'] = self.__class__.__name__
+        ex_msg['ex_args'] = self.kwargs
+        return ex_msg
 
 class EncryptionFailure(NovaException):
     msg_fmt = _("Failed to encrypt text: %(reason)s")
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/image/api.py nova/image/api.py
--- original/nova-2015.1.1/nova/image/api.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/image/api.py	2016-04-10 19:33:17.362929606 -0400
@@ -178,5 +178,6 @@
         #                 to a bytestream iterator and allows the caller to
         #                 handle streaming/copying/zero-copy as they see fit.
         session, image_id = self._get_session_and_image_id(context, id_or_uri)
+        # SYQ: label is embedded in the context
         return session.download(context, image_id, data=data,
                                 dst_path=dest_path)
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/image/glance.py nova/image/glance.py
--- original/nova-2015.1.1/nova/image/glance.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/image/glance.py	2016-04-10 19:33:17.366929695 -0400
@@ -114,11 +114,14 @@
         'X-Roles': ','.join(context.roles),
         'X-Identity-Status': status,
         'X-Service-Catalog': jsonutils.dumps(context.service_catalog),
+         # SYQ
+        'Label': getattr(context, 'label', '|'),
     }
 
 
 def _create_glance_client(context, host, port, use_ssl, version=1):
     """Instantiate a new glanceclient.Client object."""
+
     params = {}
     if use_ssl:
         scheme = 'https'
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/network/manager.py nova/network/manager.py
--- original/nova-2015.1.1/nova/network/manager.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/network/manager.py	2016-04-10 19:33:17.282927829 -0400
@@ -484,7 +484,6 @@
                                  for network in networks]
         LOG.debug('Networks retrieved for instance: |%s|',
                   networks_list, context=context, instance_uuid=instance_uuid)
-
         try:
             self._allocate_mac_addresses(admin_context, instance_uuid,
                                          networks, macs)
@@ -494,7 +493,6 @@
                 # allocated VIFs
                 objects.VirtualInterface.delete_by_instance_uuid(
                         context, instance_uuid)
-
         self._allocate_fixed_ips(admin_context, instance_uuid,
                                  host, networks, vpn=vpn,
                                  requested_networks=requested_networks)
@@ -508,6 +506,7 @@
         LOG.info(_LI("Allocated network: '%s' for instance"), net_info,
                  instance_uuid=instance_uuid,
                  context=context)
+
         return net_info
 
     def deallocate_for_instance(self, context, **kwargs):
@@ -1537,7 +1536,7 @@
             if address is not None:
                 if not netutils.is_valid_ip(address):
                     raise exception.FixedIpInvalid(address=address)
-
+    
                 fixed_ip_ref = objects.FixedIP.get_by_address(
                     context, address, expected_attrs=['network'])
                 network = fixed_ip_ref.network
@@ -1548,6 +1547,7 @@
                     raise exception.FixedIpAlreadyInUse(
                         address=address,
                         instance_uuid=fixed_ip_ref.instance_uuid)
+        print '**************SYQ: validate networks done'
 
     def _get_network_by_id(self, context, network_id):
         return objects.Network.get_by_id(context, network_id,
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/network/rpcapi.py nova/network/rpcapi.py
--- original/nova-2015.1.1/nova/network/rpcapi.py	2015-07-28 15:53:42.000000000 -0400
+++ nova/network/rpcapi.py	2016-04-10 19:33:17.282927829 -0400
@@ -23,6 +23,9 @@
 from nova.objects import base as objects_base
 from nova import rpc
 
+# SYQ
+from oslo_messaging import globalvariable as globalv
+
 rpcapi_opts = [
     cfg.StrOpt('network_topic',
                default='network',
@@ -121,6 +124,8 @@
                                                CONF.upgrade_levels.network)
         serializer = objects_base.NovaObjectSerializer()
         self.client = rpc.get_client(target, version_cap, serializer)
+        self.target = target
+        self.serializer = serializer
 
     # TODO(russellb): Convert this to named arguments.  It's a pretty large
     # list, so unwinding it all is probably best done in its own patch so it's
@@ -141,15 +146,28 @@
             if requested_networks:
                 requested_networks = requested_networks.as_tuples()
 
+        # SYQ
         if CONF.multi_host:
             cctxt = self.client.prepare(version=version, server=host)
+            args = {'version':version, 'server':host}
         else:
             cctxt = self.client.prepare(version=version)
-        return cctxt.call(ctxt, 'allocate_for_instance',
-                          instance_id=instance_id, project_id=project_id,
-                          host=host, rxtx_factor=rxtx_factor, vpn=vpn,
-                          requested_networks=requested_networks,
-                          macs=jsonutils.to_primitive(macs))
+            args = {'version': version}
+        # SYQ
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.call(ctxt, 'allocate_for_instance',
+                              instance_id=instance_id, project_id=project_id,
+                              host=host, rxtx_factor=rxtx_factor, vpn=vpn,
+                              requested_networks=requested_networks,
+                              macs=jsonutils.to_primitive(macs))
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, args, 
+                                    ctxt, 'allocate_for_instance', 
+                                    instance_id=instance_id, project_id=project_id, 
+                                    host=host, rxtx_factor=rxtx_factor, vpn=vpn, 
+                                    requested_networks=requested_networks, 
+                                    macs=jsonutils.to_primitive(macs))
+            
 
     def deallocate_for_instance(self, ctxt, instance, requested_networks=None):
         cctxt = self.client
@@ -169,7 +187,13 @@
             kwargs['project_id'] = instance.project_id
         if CONF.multi_host:
             cctxt = cctxt.prepare(server=instance.host, version=version)
-        return cctxt.call(ctxt, 'deallocate_for_instance', **kwargs)
+        # SYQ
+        args = {'server': instance.host, 'version':version}
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.call(ctxt, 'deallocate_for_instance', **kwargs)
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, args, 
+                                ctxt, 'deallocate_for_instance', **kwargs)
 
     def add_fixed_ip_to_instance(self, ctxt, instance_id, rxtx_factor,
                                  host, network_id):
@@ -193,9 +217,27 @@
     def get_instance_nw_info(self, ctxt, instance_id, rxtx_factor, host,
                              project_id):
         cctxt = self.client.prepare(version='1.9')
-        return cctxt.call(ctxt, 'get_instance_nw_info',
-                          instance_id=instance_id, rxtx_factor=rxtx_factor,
-                          host=host, project_id=project_id)
+        # SYQ
+        args = {'version': '1.9'}
+        if getattr(globalv, 'isDaemon', True):
+            # SYQ: to test dummy interface round trip latency
+            #import time
+            #t1 = time.time()
+            result = cctxt.call(ctxt, 'get_instance_nw_info',
+                              instance_id=instance_id, rxtx_factor=rxtx_factor,
+                              host=host, project_id=project_id)
+            #t2 = time.time()
+            #import pdb
+            #pdb.set_trace()
+            return result
+        else:
+            return cctxt.call_daemon(self.target, self.serializer, args, ctxt, 
+                                'get_instance_nw_info', 
+                                instance_id=instance_id, 
+                                rxtx_factor=rxtx_factor, 
+                                host=host, 
+                                project_id=project_id)
+            
 
     def validate_networks(self, ctxt, networks):
         return self.client.call(ctxt, 'validate_networks', networks=networks)
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/objects/network.py nova/objects/network.py
--- original/nova-2015.1.1/nova/objects/network.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/objects/network.py	2016-04-10 19:33:17.482932273 -0400
@@ -229,6 +229,7 @@
 
     @obj_base.remotable_classmethod
     def get_by_uuids(cls, context, network_uuids, project_only='allow_none'):
+        print '*****************SYQ: get_by_uuid'
         db_networks = db.network_get_all_by_uuids(context, network_uuids,
                                                   project_only)
         return obj_base.obj_make_list(context, cls(context), objects.Network,
Binary files original/nova-2015.1.1/nova/objects/.virtual_interface.py.swp and nova/objects/.virtual_interface.py.swp differ
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/openstack/common/loopingcall.py nova/openstack/common/loopingcall.py
--- original/nova-2015.1.1/nova/openstack/common/loopingcall.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/openstack/common/loopingcall.py	2016-04-10 19:33:18.442953599 -0400
@@ -56,6 +56,8 @@
         self.f = f
         self._running = False
         self.done = None
+        # SYQ
+        self.pause = False
 
     def stop(self):
         self._running = False
@@ -77,6 +79,9 @@
 
             try:
                 while self._running:
+                    if self.pause:
+                        greenthread.sleep(0)
+                        continue
                     start = _ts()
                     self.f(*self.args, **self.kw)
                     end = _ts()
@@ -121,6 +126,9 @@
 
             try:
                 while self._running:
+                    if self.pause:
+                        greenthread.sleep(0)
+                        continue
                     idle = self.f(*self.args, **self.kw)
                     if not self._running:
                         break
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/openstack/common/threadgroup.py nova/openstack/common/threadgroup.py
--- original/nova-2015.1.1/nova/openstack/common/threadgroup.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/openstack/common/threadgroup.py	2016-04-10 19:33:18.446953689 -0400
@@ -147,3 +147,12 @@
                 pass
             except Exception as ex:
                 LOG.exception(ex)
+    
+    # SYQ
+    def pause(self):
+        for x in self.timers:
+            x.pause = True
+
+    def unpause(self):
+        for x in self.timers:
+            x.pause = False
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/rpc.py nova/rpc.py
--- original/nova-2015.1.1/nova/rpc.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/rpc.py	2016-04-10 19:33:17.602934939 -0400
@@ -26,6 +26,9 @@
     'TRANSPORT_ALIASES',
 ]
 
+# SYQ
+from oslo_messaging import globalvariable as globalv
+
 from oslo_config import cfg
 import oslo_messaging as messaging
 from oslo_serialization import jsonutils
@@ -63,7 +66,7 @@
                                         aliases=TRANSPORT_ALIASES)
     serializer = RequestContextSerializer(JsonPayloadSerializer())
     NOTIFIER = messaging.Notifier(TRANSPORT, serializer=serializer)
-
+    globalv.init_transport(TRANSPORT)
 
 def cleanup():
     global TRANSPORT, NOTIFIER
@@ -137,6 +140,8 @@
                                     target,
                                     endpoints,
                                     executor='eventlet',
+#SYQ
+#                                    executor='threading',
                                     serializer=serializer)
 
 
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/scheduler/rpcapi.py nova/scheduler/rpcapi.py
--- original/nova-2015.1.1/nova/scheduler/rpcapi.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/scheduler/rpcapi.py	2016-04-10 19:33:17.222926496 -0400
@@ -22,6 +22,9 @@
 from nova.objects import base as objects_base
 from nova import rpc
 
+# SYQ
+from oslo_messaging import globalvariable as globalv
+
 rpcapi_opts = [
     cfg.StrOpt('scheduler_topic',
                default='scheduler',
@@ -113,6 +116,8 @@
         serializer = objects_base.NovaObjectSerializer()
         self.client = rpc.get_client(target, version_cap=version_cap,
                                      serializer=serializer)
+        self.target = target
+        self.serializer = serializer
 
     def select_destinations(self, ctxt, request_spec, filter_properties):
         cctxt = self.client.prepare(version='4.0')
@@ -131,15 +136,38 @@
 
     def update_instance_info(self, ctxt, host_name, instance_info):
         cctxt = self.client.prepare(version='4.2', fanout=True)
-        return cctxt.cast(ctxt, 'update_instance_info', host_name=host_name,
-                          instance_info=instance_info)
+        # SYQ
+        args = {'version': '4.2', 'fanout': True}
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.cast(ctxt, 'update_instance_info', host_name=host_name,
+                              instance_info=instance_info)
+        else:
+            return cctxt.cast_daemon(self.target, self.serializer, args, ctxt, 
+                                    'update_instance_info', host_name=host_name, 
+                                    instance_info=instance_info)
+            
 
     def delete_instance_info(self, ctxt, host_name, instance_uuid):
         cctxt = self.client.prepare(version='4.2', fanout=True)
-        return cctxt.cast(ctxt, 'delete_instance_info', host_name=host_name,
-                          instance_uuid=instance_uuid)
+        # SYQ
+        args = {'version': '4.2', 'fanout': True}
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.cast(ctxt, 'delete_instance_info', host_name=host_name,
+                              instance_uuid=instance_uuid)
+        else:
+            return cctxt.cast_daemon(self.target, self.serializer, args, ctxt, 
+                                    'delete_instance_info', host_name=host_name, 
+                                    instance_uuid=instance_uuid)
+            
 
     def sync_instance_info(self, ctxt, host_name, instance_uuids):
         cctxt = self.client.prepare(version='4.2', fanout=True)
-        return cctxt.cast(ctxt, 'sync_instance_info', host_name=host_name,
-                          instance_uuids=instance_uuids)
+        # SYQ
+        args = {'version': '4.2', 'fanout': True}
+        if getattr(globalv, 'isDaemon', True):
+            return cctxt.cast(ctxt, 'sync_instance_info', host_name=host_name,
+                              instance_uuids=instance_uuids)
+        else:
+            return cctxt.cast_daemon(self.target, self.serializer, args, ctxt, 
+                                    'sync_instance_info', host_name=host_name, 
+                                    instance_uuids=instance_uuids)
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/servicegroup/drivers/db.py nova/servicegroup/drivers/db.py
--- original/nova-2015.1.1/nova/servicegroup/drivers/db.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/servicegroup/drivers/db.py	2016-04-10 19:33:18.402952711 -0400
@@ -24,6 +24,8 @@
 from nova.servicegroup import api
 from nova.servicegroup.drivers import base
 
+# SYQ
+from oslo_messaging import globalvariable as globalv
 
 CONF = cfg.CONF
 CONF.import_opt('service_down_time', 'nova.service')
@@ -102,6 +104,13 @@
 
     def _report_state(self, service):
         """Update the state of this service in the datastore."""
+
+        # SYQ
+        # Only daemon can make periodical calls
+        #if hasattr(globalv, 'isDaemon'):
+        #    if globalv.isDaemon == False:
+        #        return 
+
         ctxt = context.get_admin_context()
         state_catalog = {}
         try:
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/service.py nova/service.py
--- original/nova-2015.1.1/nova/service.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/service.py	2016-04-10 19:33:17.366929695 -0400
@@ -21,6 +21,11 @@
 import random
 import sys
 
+# SYQ
+from oslo_messaging import globalvariable as globalv
+from multiprocessing import Process
+import eventlet
+
 from oslo_concurrency import processutils
 from oslo_config import cfg
 from oslo_log import log as logging
@@ -154,6 +159,24 @@
         self.saved_args, self.saved_kwargs = args, kwargs
         self.backdoor_port = None
         self.conductor_api = conductor.API(use_local=db_allowed)
+
+        # SYQ
+        # To enable/disable debug
+        self.pileus_debug = False
+
+        self.is_conductor = False       
+ 
+        # SYQ: try fork here
+        # must fork before here, looks like conductor_api.wait_until_ready is
+        # the problem
+        #def test():
+        #    while True:
+        #        eventlet.sleep(1)
+        #        print '**********SYQ: pid %s running'%os.getpid()
+
+        #p = Process(target=test)
+        #p.start()
+        
         self.conductor_api.wait_until_ready(context.get_admin_context())
 
     def start(self):
@@ -197,6 +220,7 @@
 
         serializer = objects_base.NovaObjectSerializer()
 
+        
         self.rpcserver = rpc.get_server(target, endpoints, serializer)
         self.rpcserver.start()
 
@@ -205,6 +229,7 @@
         LOG.debug("Join ServiceGroup membership for this service %s",
                   self.topic)
         # Add service to the ServiceGroup membership group.
+        # SYQ: This adds the timer(greenthread) for the _report_state
         self.servicegroup_api.join(self.host, self.topic, self)
 
         if self.periodic_enable:
@@ -212,12 +237,17 @@
                 initial_delay = random.randint(0, self.periodic_fuzzy_delay)
             else:
                 initial_delay = None
-
+            # SYQ: This adds dynamic timer(greenthread) for other periodic tasks
             self.tg.add_dynamic_timer(self.periodic_tasks,
                                      initial_delay=initial_delay,
                                      periodic_interval_max=
                                         self.periodic_interval_max)
 
+        # SYQ
+        globalv.init(self)
+        print '*************SYQ: service init pid is %s'%os.getpid()
+        
+
     def _create_service_ref(self, context):
         svc_values = {
             'host': self.host,
@@ -318,6 +348,11 @@
             sys.exit(1)
 
 
+    #SYQ
+    def set_pipe(self, child_pipe, parent_pipe):
+        self.child_pipe = child_pipe
+        self.parent_pipe = parent_pipe
+
 class WSGIService(object):
     """Provides ability to launch API from a 'paste' configuration."""
 
@@ -359,6 +394,7 @@
         # Pull back actual port used
         self.port = self.server.port
         self.backdoor_port = None
+        self.pileus_debug = False
 
     def reset(self):
         """Reset server greenpool size to default.
@@ -406,6 +442,8 @@
         self.server.start()
         if self.manager:
             self.manager.post_start_hook()
+        # SYQ
+        globalv.init(self)
 
     def stop(self):
         """Stop serving this API.
@@ -422,6 +460,11 @@
 
         """
         self.server.wait()
+    
+    #SYQ
+    def set_pipe(self, child_pipe, parent_pipe):
+        self.child_pipe = child_pipe
+        self.parent_pipe = parent_pipe
 
 
 def process_launcher():
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/cmd/test_baseproxy.py nova/tests/unit/cmd/test_baseproxy.py
--- original/nova-2015.1.1/nova/tests/unit/cmd/test_baseproxy.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/tests/unit/cmd/test_baseproxy.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,64 +0,0 @@
-# Copyright 2015 IBM Corp.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import mock
-from oslo_log import log as logging
-
-from nova.cmd import baseproxy
-from nova import config
-from nova.console import websocketproxy
-from nova.openstack.common.report import guru_meditation_report as gmr
-from nova import test
-from nova import version
-
-
-@mock.patch.object(config, 'parse_args', new=lambda *args, **kwargs: None)
-class BaseProxyTestCase(test.NoDBTestCase):
-
-    @mock.patch('os.path.exists', return_value=False)
-    # NOTE(mriedem): sys.exit raises TestingException so we can actually exit
-    # the test normally.
-    @mock.patch('sys.exit', side_effect=test.TestingException)
-    def test_proxy_ssl_without_cert(self, mock_exit, mock_exists):
-        self.flags(ssl_only=True)
-        self.assertRaises(test.TestingException, baseproxy.proxy,
-                          '0.0.0.0', '6080')
-        mock_exit.assert_called_once_with(-1)
-
-    @mock.patch('os.path.exists', return_value=False)
-    @mock.patch('sys.exit', side_effect=test.TestingException)
-    def test_proxy_web_dir_does_not_exist(self, mock_exit, mock_exists):
-        self.flags(web='/my/fake/webserver/')
-        self.assertRaises(test.TestingException, baseproxy.proxy,
-                          '0.0.0.0', '6080')
-        mock_exit.assert_called_once_with(-1)
-
-    @mock.patch('os.path.exists', return_value=True)
-    @mock.patch.object(logging, 'setup')
-    @mock.patch.object(gmr.TextGuruMeditation, 'setup_autorun')
-    @mock.patch.object(websocketproxy.NovaWebSocketProxy, '__init__',
-                       return_value=None)
-    @mock.patch.object(websocketproxy.NovaWebSocketProxy, 'start_server')
-    def test_proxy(self, mock_start, mock_init, mock_gmr, mock_log,
-                   mock_exists):
-        baseproxy.proxy('0.0.0.0', '6080')
-        mock_log.assert_called_once_with(baseproxy.CONF, 'nova')
-        mock_gmr.mock_assert_called_once_with(version)
-        mock_init.assert_called_once_with(
-            listen_host='0.0.0.0', listen_port='6080', source_is_ipv6=False,
-            verbose=False, cert='self.pem', key=None, ssl_only=False,
-            daemon=False, record=False, traffic=False,
-            web='/usr/share/spice-html5', file_only=True,
-            RequestHandlerClass=websocketproxy.NovaProxyRequestHandler)
-        mock_start.assert_called_once_with()
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/compute/test_claims.py nova/tests/unit/compute/test_claims.py
--- original/nova-2015.1.1/nova/tests/unit/compute/test_claims.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/tests/unit/compute/test_claims.py	2016-04-10 19:33:17.726937694 -0400
@@ -177,18 +177,24 @@
 
     def test_disk_insufficient(self, mock_get):
         limits = {'disk_gb': 45}
-        self.assertRaisesRegex(
-                exception.ComputeResourcesUnavailable,
-                "disk",
-                self._claim, limits=limits, root_gb=10, ephemeral_gb=40)
+        try:
+            self.assertRaisesRegex(
+                    exception.ComputeResourcesUnavailable,
+                    "disk",
+                    self._claim, limits=limits, root_gb=10, ephemeral_gb=40)
+        except:
+            self.skipTest('Skipped by Ubuntu')
 
     def test_disk_and_memory_insufficient(self, mock_get):
         limits = {'disk_gb': 45, 'memory_mb': 8192}
-        self.assertRaisesRegex(
-                exception.ComputeResourcesUnavailable,
-                "memory.*disk",
-                self._claim, limits=limits, root_gb=10, ephemeral_gb=40,
-                memory_mb=16384)
+        try:
+            self.assertRaisesRegex(
+                    exception.ComputeResourcesUnavailable,
+                    "memory.*disk",
+                    self._claim, limits=limits, root_gb=10, ephemeral_gb=40,
+                    memory_mb=16384)
+        except:
+            self.skipTest('Skipped by Ubuntu')
 
     @pci_fakes.patch_pci_whitelist
     def test_pci_pass(self, mock_get):
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/console/test_websocketproxy.py nova/tests/unit/console/test_websocketproxy.py
--- original/nova-2015.1.1/nova/tests/unit/console/test_websocketproxy.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/tests/unit/console/test_websocketproxy.py	2016-04-10 19:33:17.706937249 -0400
@@ -16,8 +16,13 @@
 
 
 import mock
+import testtools
+
+try:
+    from nova.console import websocketproxy
+except:
+    websocketproxy = None
 
-from nova.console import websocketproxy
 from nova import exception
 from nova import test
 from oslo_config import cfg
@@ -27,6 +32,7 @@
 
 class NovaProxyRequestHandlerBaseTestCase(test.NoDBTestCase):
 
+    @testtools.skipIf(websocketproxy is None, "websockify not available")
     def setUp(self):
         super(NovaProxyRequestHandlerBaseTestCase, self).setUp()
 
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/objects/test_objects.py nova/tests/unit/objects/test_objects.py
--- original/nova-2015.1.1/nova/tests/unit/objects/test_objects.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/tests/unit/objects/test_objects.py	2016-04-10 19:33:17.946942581 -0400
@@ -514,8 +514,11 @@
         class Foo(base.NovaObject):
             fields = {'foobar': fields.Field(fields.Integer())}
         obj = Foo()
-        with self.assertRaisesRegex(NotImplementedError, ".*foobar.*"):
-            obj.foobar
+        try:
+            with self.assertRaisesRegex(NotImplementedError, ".*foobar.*"):
+                obj.foobar
+        except:
+            self.skipTest('Skipped by Ubuntu')
 
     def test_loaded_in_primitive(self):
         obj = MyObj(foo=1)
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/test_cinder.py nova/tests/unit/test_cinder.py
--- original/nova-2015.1.1/nova/tests/unit/test_cinder.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/tests/unit/test_cinder.py	2016-04-10 19:33:18.086945691 -0400
@@ -115,15 +115,21 @@
                          self.create_client().client.endpoint_override)
 
     def test_get_non_existing_volume(self):
-        self.requests.get(self.URL + '/volumes/nonexisting',
-                          status_code=404)
+        try:
+            self.requests.get(self.URL + '/volumes/nonexisting',
+                              status_code=404)
+        except:
+            self.skipTest('Failed to connect')
 
         self.assertRaises(exception.VolumeNotFound, self.api.get, self.context,
                           'nonexisting')
 
     def test_volume_with_image_metadata(self):
         v = self.stub_volume(id='1234', volume_image_metadata=_image_metadata)
-        m = self.requests.get(self.URL + '/volumes/5678', json={'volume': v})
+        try:
+            m = self.requests.get(self.URL + '/volumes/5678', json={'volume': v})
+        except:
+            self.skipTest('Skipped by Ubuntu')
 
         volume = self.api.get(self.context, '5678')
         self.assertThat(m.last_request.path,
@@ -175,19 +181,28 @@
     def test_cinder_endpoint_template(self):
         endpoint = 'http://other_host:8776/v2/%(project_id)s'
         self.flags(endpoint_template=endpoint, group='cinder')
-        self.assertEqual('http://other_host:8776/v2/project_id',
-                         self.create_client().client.endpoint_override)
+        try:
+            self.assertEqual('http://other_host:8776/v2/project_id',
+                             self.create_client().client.endpoint_override)
+        except:
+            self.skipTest('Skipped by Ubuntu')
 
     def test_get_non_existing_volume(self):
-        self.requests.get(self.URL + '/volumes/nonexisting',
-                          status_code=404)
+        try:
+            self.requests.get(self.URL + '/volumes/nonexisting',
+                              status_code=404)
+        except:
+            self.skipTest('Skipped by Ubuntu')
 
         self.assertRaises(exception.VolumeNotFound, self.api.get, self.context,
                           'nonexisting')
 
     def test_volume_with_image_metadata(self):
         v = self.stub_volume(id='1234', volume_image_metadata=_image_metadata)
-        self.requests.get(self.URL + '/volumes/5678', json={'volume': v})
+        try:
+            self.requests.get(self.URL + '/volumes/5678', json={'volume': v})
+        except:
+            self.skipTest('Environment not setup')
         volume = self.api.get(self.context, '5678')
         self.assertIn('volume_image_metadata', volume)
         self.assertEqual(_image_metadata, volume['volume_image_metadata'])
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/test_fixtures.py nova/tests/unit/test_fixtures.py
--- original/nova-2015.1.1/nova/tests/unit/test_fixtures.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/tests/unit/test_fixtures.py	2016-04-10 19:33:17.734937871 -0400
@@ -152,6 +152,7 @@
 
 class TestOSAPIFixture(testtools.TestCase):
     def test_responds_to_version(self):
+        self.skipTest("Disabled on Ubuntu due to failure in LP buildd")
         """Ensure the OSAPI server responds to calls sensibly."""
         self.useFixture(fixtures.OutputStreamCapture())
         self.useFixture(fixtures.StandardLogging())
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/test_wsgi.py nova/tests/unit/test_wsgi.py
--- original/nova-2015.1.1/nova/tests/unit/test_wsgi.py	2015-07-28 15:53:35.000000000 -0400
+++ nova/tests/unit/test_wsgi.py	2016-04-10 19:33:18.078945513 -0400
@@ -327,8 +327,11 @@
 
         server.start()
 
-        response = requests.get('https://[::1]:%d/' % server.port,
-                                verify=os.path.join(SSL_CERT_DIR, 'ca.crt'))
+        try:
+            response = requests.get('https://[::1]:%d/' % server.port,
+                                    verify=os.path.join(SSL_CERT_DIR, 'ca.crt'))
+        except:
+            self.skipTest('Skipped by Ubuntu')
         self.assertEqual(greetings, response.text)
 
         server.stop()
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/tests/unit/virt/libvirt/test_driver.py nova/tests/unit/virt/libvirt/test_driver.py
--- original/nova-2015.1.1/nova/tests/unit/virt/libvirt/test_driver.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/tests/unit/virt/libvirt/test_driver.py	2016-04-10 19:33:17.782938937 -0400
@@ -1033,7 +1033,7 @@
         self.assertEqual(1, cfg.vcpus)
         self.assertEqual(vm_mode.EXE, cfg.os_type)
         self.assertEqual("/sbin/init", cfg.os_init_path)
-        self.assertEqual("console=tty0 console=ttyS0", cfg.os_cmdline)
+        self.assertEqual("console=tty0 console=ttyS0 console=ttyAMA0", cfg.os_cmdline)
         self.assertIsNone(cfg.os_root)
         self.assertEqual(3, len(cfg.devices))
         self.assertIsInstance(cfg.devices[0],
@@ -1057,7 +1057,7 @@
         self.assertEqual(1, cfg.vcpus)
         self.assertEqual(vm_mode.EXE, cfg.os_type)
         self.assertEqual("/sbin/init", cfg.os_init_path)
-        self.assertEqual("console=tty0 console=ttyS0", cfg.os_cmdline)
+        self.assertEqual("console=tty0 console=ttyS0 console=ttyAMA0", cfg.os_cmdline)
         self.assertIsNone(cfg.os_root)
         self.assertEqual(3, len(cfg.devices))
         self.assertIsInstance(cfg.devices[0],
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/utils.py nova/utils.py
--- original/nova-2015.1.1/nova/utils.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/utils.py	2016-04-10 19:33:17.474932095 -0400
@@ -984,12 +984,31 @@
     def context_wrapper(*args, **kwargs):
         # NOTE: If update_store is not called after spawn_n it won't be
         # available for the logger to pull from threadlocal storage.
+        print '************SYQ: spawn thread for %s'%func
         if _context is not None:
             _context.update_store()
         func(*args, **kwargs)
 
+    print '************SYQ: I am here'
     eventlet.spawn_n(context_wrapper, *args, **kwargs)
 
+# SYQ
+# Block until the thread finish so that the process will not terminate
+def block_spawn(func, *args, **kwargs):
+    _context = common_context.get_current()
+
+    @functools.wraps(func)
+    def context_wrapper(*args, **kwargs):
+        # NOTE: If update_store is not called after spawn_n it won't be
+        # available for the logger to pull from threadlocal storage.
+        print '************SYQ: spawn thread for %s'%func
+        if _context is not None:
+            _context.update_store()
+        func(*args, **kwargs)
+
+    print '************SYQ: I am here'
+    thread = eventlet.spawn(context_wrapper, *args, **kwargs)
+    thread.wait()
 
 def is_none_string(val):
     """Check if a string represents a None value.
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/virt/libvirt/driver.py nova/virt/libvirt/driver.py
--- original/nova-2015.1.1/nova/virt/libvirt/driver.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/virt/libvirt/driver.py	2016-04-10 19:33:17.450931562 -0400
@@ -263,7 +263,7 @@
 DISABLE_REASON_UNDEFINED = None
 
 # Guest config console string
-CONSOLE = "console=tty0 console=ttyS0"
+CONSOLE = "console=tty0 console=ttyS0 console=ttyAMA0"
 
 GuestNumaConfig = collections.namedtuple(
     'GuestNumaConfig', ['cpuset', 'cputune', 'numaconfig', 'numatune'])
@@ -2366,6 +2366,7 @@
     # for xenapi(tr3buchet)
     def spawn(self, context, instance, image_meta, injected_files,
               admin_password, network_info=None, block_device_info=None):
+
         disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,
                                             instance,
                                             image_meta,
@@ -2704,7 +2705,9 @@
         booted_from_volume = self._is_booted_from_volume(
             instance, disk_mapping)
 
+
         def image(fname, image_type=CONF.libvirt.images_type):
+            # image type is default (qcow backend is used)
             return self.image_backend.image(instance,
                                             fname + suffix, image_type)
 
@@ -2733,6 +2736,8 @@
                            'ramdisk_id': instance.ramdisk_id}
 
         if disk_images['kernel_id']:
+            # SYQ
+            # Not executed in current image format
             fname = imagecache.get_cache_fname(disk_images, 'kernel_id')
             raw('kernel').cache(fetch_func=libvirt_utils.fetch_image,
                                 context=context,
@@ -2755,6 +2760,8 @@
         # currently happens only on rescue - we still don't want to
         # create a base image.
         if not booted_from_volume:
+            # SYQ
+            # Executed
             root_fname = imagecache.get_cache_fname(disk_images, 'image_id')
             size = instance.root_gb * units.Gi
 
@@ -2763,6 +2770,7 @@
 
             backend = image('disk')
             if backend.SUPPORTS_CLONE:
+                # SYQ: not executed
                 def clone_fallback_to_fetch(*args, **kwargs):
                     try:
                         backend.clone(context, disk_images['image_id'])
@@ -2770,6 +2778,8 @@
                         libvirt_utils.fetch_image(*args, **kwargs)
                 fetch_func = clone_fallback_to_fetch
             else:
+                # SYQ: executed
+                print '*************SYQ:fetch function is libvirt_utils.fetch_image'
                 fetch_func = libvirt_utils.fetch_image
             self._try_fetch_image_cache(backend, fetch_func, context,
                                         root_fname, disk_images['image_id'],
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/virt/libvirt/host.py nova/virt/libvirt/host.py
--- original/nova-2015.1.1/nova/virt/libvirt/host.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/virt/libvirt/host.py	2016-04-10 19:33:17.450931562 -0400
@@ -53,6 +53,9 @@
 from nova.virt.libvirt import compat
 from nova.virt.libvirt import config as vconfig
 
+# SYQ
+from oslo_messaging import globalvariable as globalv
+
 libvirt = None
 
 LOG = logging.getLogger(__name__)
@@ -209,6 +212,7 @@
         #                down the domain during a reboot, delay the
         #                STOPPED lifecycle event some seconds.
         self._lifecycle_delay = 15
+        self._pid = os.getpid()
 
     def _native_thread(self):
         """Receives async events coming in from libvirtd.
@@ -306,9 +310,32 @@
         # tpool.proxy_call creates a native thread. Due to limitations
         # with eventlet locking we cannot use the logging API inside
         # the called function.
-        return tpool.proxy_call(
+        # SYQ
+        print '*******************SYQ: before tpool.proxy_call'
+        # When creating a new connection, stuck here
+        a =  tpool.proxy_call(
             (libvirt.virDomain, libvirt.virConnect),
             libvirt.openAuth, uri, auth, flags)
+        print '*******************SYQ: after tpool.proxy_call'
+        return a
+
+    # SYQ
+    @staticmethod
+    def _connect_block(uri, read_only):
+        auth = [[libvirt.VIR_CRED_AUTHNAME,
+                 libvirt.VIR_CRED_ECHOPROMPT,
+                 libvirt.VIR_CRED_REALM,
+                 libvirt.VIR_CRED_PASSPHRASE,
+                 libvirt.VIR_CRED_NOECHOPROMPT,
+                 libvirt.VIR_CRED_EXTERNAL],
+                Host._connect_auth_cb,
+                None]
+
+        flags = 0
+        if read_only:
+            flags = libvirt.VIR_CONNECT_RO
+        return libvirt.openAuth(uri, auth, flags)
+        
 
     def _queue_event(self, event):
         """Puts an event on the queue for dispatch.
@@ -451,13 +478,17 @@
         LOG.debug("Starting green dispatch thread")
         eventlet.spawn(self._dispatch_thread)
 
-    def _get_new_connection(self):
+    # SYQ
+    def _get_new_connection(self, block=False):
         # call with _wrapped_conn_lock held
         LOG.debug('Connecting to libvirt: %s', self._uri)
         wrapped_conn = None
 
         try:
-            wrapped_conn = self._connect(self._uri, self._read_only)
+            if not block: 
+                wrapped_conn = self._connect(self._uri, self._read_only)
+            else:
+                wrapped_conn = self._connect_block(self._uri, self._read_only)
         finally:
             # Enabling the compute service, in case it was disabled
             # since the connection was successful.
@@ -504,9 +535,19 @@
         # multiple concurrent connections are protected by _wrapped_conn_lock
         with self._wrapped_conn_lock:
             wrapped_conn = self._wrapped_conn
-            if not wrapped_conn or not self._test_connection(wrapped_conn):
-                wrapped_conn = self._get_new_connection()
-
+            # SYQ
+            current_pid = os.getpid()
+            if getattr(globalv, 'isDaemon', True):
+                if not wrapped_conn or not self._test_connection(wrapped_conn):
+                    wrapped_conn = self._get_new_connection()
+            elif self._pid == current_pid:
+                if not wrapped_conn or not self._test_connection(wrapped_conn):
+                    wrapped_conn = self._get_new_connection(block=True)
+            else:
+                self._pid = current_pid
+                wrapped_conn = self._get_new_connection(block=True)
+            #if not wrapped_conn or not self._test_connection(wrapped_conn):
+            #    wrapped_conn = self._get_new_connection()
         return wrapped_conn
 
     def get_connection(self):
diff -uNr -x '*.pyc' original/nova-2015.1.1/nova/virt/libvirt/imagebackend.py nova/virt/libvirt/imagebackend.py
--- original/nova-2015.1.1/nova/virt/libvirt/imagebackend.py	2015-07-28 15:53:43.000000000 -0400
+++ nova/virt/libvirt/imagebackend.py	2016-04-10 19:33:17.450931562 -0400
@@ -226,6 +226,7 @@
             fileutils.ensure_tree(base_dir)
         base = os.path.join(base_dir, filename)
 
+        # SYQ: Qcow is used
         if not self.check_image_exists() or not os.path.exists(base):
             self.create_image(fetch_func_sync, base, size,
                               *args, **kwargs)
@@ -419,7 +420,6 @@
 
     def create_image(self, prepare_template, base, size, *args, **kwargs):
         filename = self._get_lock_name(base)
-
         @utils.synchronized(filename, external=True, lock_path=self.lock_path)
         def copy_raw_image(base, target, size):
             libvirt_utils.copy_image(base, target)
@@ -474,7 +474,6 @@
             libvirt_utils.create_cow_image(base, target)
             if size:
                 disk.extend(target, size, use_cow=True)
-
         # Download the unmodified base image unless we already have a copy.
         if not os.path.exists(base):
             prepare_template(target=base, max_size=size, *args, **kwargs)
